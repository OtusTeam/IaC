leksey@first:~/OtusTeam/IaC/les13/plugin$ ls
ansible.cfg  ans_inv_list.sh  ans_ping.sh  create_vm.sh  export_plg.sh  inventory  plugins  running.log  set_grep_ANSIBLE.sh
aleksey@first:~/OtusTeam/IaC/les13/plugin$ cat ansible.cfg 
[defaults]
# не проверять ключ удаленного хоста (они могут быть каждый раз разные)
host_key_checking = false
# путь к локальному инвентори каталогу 
inventory = ./inventory
# путь к локальному каталогу с инвентори плагинами 
inventory_plugins = ./plugins/inventory
#./plugins/inventory
# default remote username
remote_user = ${ANSIBLE_REMOTE_USER}

[inventory]
#enable_plugins = namespace.collection_name.inventory_plugin_name
enable_plugins = host_list,script,auto,yaml,ini,toml,yacloud_compute


aleksey@first:~/OtusTeam/IaC/les13/plugin$ cat inventory/yacloud_compute.yml 
plugin: yacloud_compute
yacloud_iam_token: "$YC_TOKEN"
yacloud_clouds:
- cloud-aleksey-jhuravlev
yacloud_folders:
- otus
aleksey@first:~/OtusTeam/IaC/les13/plugin$ cat create_vm.sh 
#!/bin/bash

if [ $# -eq 1 ]; then
   echo "vm_name=$1 will be used to create VM"
else
   echo "Error: required parameter not specified!"
   echo "Call $0 vm_name"
   exit 1
fi

export VM_NAME="$1"
export YC_IMAGE_ID="fd8pecdhv50nec1qf9im"
export YC_SUBNET_ID="e9bop98iu12teftg4uj8"


yc compute instance create \
  --name $VM_NAME \
  --hostname $VM_NAME \
  --zone=$YC_ZONE \
  --create-boot-disk size=20GB,image-id=$YC_IMAGE_ID \
  --cores=2 \
  --memory=2G \
  --core-fraction=20 \
  --preemptible \
  --network-interface subnet-id=$YC_SUBNET_ID,ipv4-address=auto,nat-ip-version=ipv4 \
  --ssh-key ~/.ssh/id_rsa.pub
aleksey@first:~/OtusTeam/IaC/les13/plugin$ ./create_vm.sh test
vm_name=test will be used to create VM
done (44s)
id: fhmrg6to0hq7qiadj4i0
folder_id: b1gmesrdjgklgkvcp704
created_at: "2024-08-19T13:59:18Z"
name: test
zone_id: ru-central1-a
platform_id: standard-v2
resources:
  memory: "2147483648"
  cores: "2"
  core_fraction: "20"
status: RUNNING
metadata_options:
  gce_http_endpoint: ENABLED
  aws_v1_http_endpoint: ENABLED
  gce_http_token: ENABLED
  aws_v1_http_token: DISABLED
boot_disk:
  mode: READ_WRITE
  device_name: fhm9n1gsp77o4aaihsnt
  auto_delete: true
  disk_id: fhm9n1gsp77o4aaihsnt
network_interfaces:
  - index: "0"
    mac_address: d0:0d:1b:81:bb:80
    subnet_id: e9bop98iu12teftg4uj8
    primary_v4_address:
      address: 10.128.0.30
      one_to_one_nat:
        address: 89.169.147.135
        ip_version: IPV4
serial_port_settings:
  ssh_authorization: INSTANCE_METADATA
gpu_settings: {}
fqdn: test.ru-central1.internal
scheduling_policy:
  preemptible: true
network_settings:
  type: STANDARD
placement_policy: {}

aleksey@first:~/OtusTeam/IaC/les13/plugin$ cat plugins/inventory/yacloud_compute.py 
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

# about yacloud_iam_token added by JA:
DOCUMENTATION = '''
    name: yacloud_compute
    plugin_type: inventory
    short_description: Yandex.Cloud compute inventory source
    requirements:
        - yandexcloud
    extends_documentation_fragment:
        - inventory_cache
        - constructed
    description:
        - Get inventory hosts from Yandex Cloud
        - Uses a YAML configuration file that ends with C(yacloud_compute.(yml|yaml)).
    options:
        plugin:
            description: Token that ensures this is a source file for the plugin.
            required: True
            choices: ['yacloud_compute']
        yacloud_token:
            description: Oauth token for yacloud connection
        yacloud_iam_token:
            description: iam token for yacloud connection
        yacloud_token_file:
            description: File with oauth token for yacloud connection
        yacloud_clouds:
            description: Names of clouds to get hosts from
            type: list
            default: []
        yacloud_folders:
            description: Names of folders to get hosts from
            type: list
            default: []
        yacloud_group_label:
            description: VM's label used for group assignment
            type: string
            default: ""
            
'''

EXAMPLES = '''
'''

from ansible.errors import AnsibleError
from ansible.plugins.inventory import BaseInventoryPlugin, Constructable, Cacheable
from ansible.utils.display import Display
from ansible.module_utils._text import to_native
# added by JA:
import os

try:
    import yandexcloud
    from yandex.cloud.compute.v1.instance_service_pb2_grpc import InstanceServiceStub
    from yandex.cloud.compute.v1.instance_service_pb2 import ListInstancesRequest
    from google.protobuf.json_format import MessageToDict
    from yandex.cloud.resourcemanager.v1.cloud_service_pb2 import ListCloudsRequest
    from yandex.cloud.resourcemanager.v1.cloud_service_pb2_grpc import CloudServiceStub
    from yandex.cloud.resourcemanager.v1.folder_service_pb2 import ListFoldersRequest
    from yandex.cloud.resourcemanager.v1.folder_service_pb2_grpc import FolderServiceStub
except ImportError:
    raise AnsibleError('The yacloud dynamic inventory plugin requires yandexcloud')

display = Display()


class InventoryModule(BaseInventoryPlugin, Constructable, Cacheable):

    NAME = 'yacloud_compute'

    def verify_file(self, path):
        if super(InventoryModule, self).verify_file(path):
            if path.endswith(('yacloud_compute.yml', 'yacloud_compute.yaml')):
                return True
        display.debug("yacloud_compute inventory filename must end with 'yacloud_compute.yml' or 'yacloud_compute.yaml'")
        return False

    def _get_ip_for_instance(self, instance):
        interfaces = instance["networkInterfaces"]
        for interface in interfaces:
            address = interface["primaryV4Address"]
            if address:
                if address.get("oneToOneNat"):
                    return address["oneToOneNat"]["address"]
                else:
                    return address["address"]
        return None

    def _get_clouds(self):
        all_clouds = MessageToDict(self.cloud_service.List(ListCloudsRequest()))["clouds"]
        if self.get_option('yacloud_clouds'):
            all_clouds[:] = [x for x in all_clouds if x["name"] in self.get_option('yacloud_clouds')]
        self.clouds = all_clouds

    def _get_folders(self):
        all_folders = []
        for cloud in self.clouds:
            all_folders += MessageToDict(self.folder_service.List(ListFoldersRequest(cloud_id=cloud["id"])))["folders"]

        if self.get_option('yacloud_folders'):
            all_folders[:] = [x for x in all_folders if x["name"] in self.get_option('yacloud_folders')]

        self.folders = all_folders

    def _get_all_hosts(self):
        self.hosts = []
        for folder in self.folders:
            hosts = self.instance_service.List(ListInstancesRequest(folder_id=folder["id"]))
            dict_ = MessageToDict(hosts)

            if dict_:
                self.hosts += dict_["instances"]

    def _init_client(self):
        file = self.get_option('yacloud_token_file')
        if file is not None:
            token = open(file).read().strip()
        else:
            token = self.get_option('yacloud_token')
#       added iam_token by JA:
            iam_token = self.get_option('yacloud_iam_token')
#       iam _token can be also specified e.g. as "$YC_IAM_TOKEN" this means take the iam_token from environment variable "YC_IAM_TOKEN"
            if iam_token[0] == '$':
               iam_token = os.getenv(iam_token[1:])

        if token:
           sdk = yandexcloud.SDK(token=token)
        elif iam_token:
           sdk = yandexcloud.SDK(iam_token=iam_token)
        else:
            raise AnsibleError("token it empty. provide either `yacloud_token_file` or `yacloud_token` or `yacloud_iam_token`")

        self.instance_service = sdk.client(InstanceServiceStub)
        self.folder_service = sdk.client(FolderServiceStub)
        self.cloud_service = sdk.client(CloudServiceStub)

    def _process_hosts(self):
        group_label = str(self.get_option('yacloud_group_label'))

        for instance in self.hosts:
            if group_label and group_label in instance["labels"]:
                group = instance["labels"][group_label]
            else:
                group = "yacloud"

            self.inventory.add_group(group=group)
            if instance["status"] == "RUNNING":
                ip = self._get_ip_for_instance(instance)
                if ip:
                    self.inventory.add_host(instance["name"], group=group)
                    self.inventory.set_variable(instance["name"], 'ansible_host', to_native(ip))

    def parse(self, inventory, loader, path, cache=True):
        super(InventoryModule, self).parse(inventory, loader, path)

        self._read_config_data(path)
        self._init_client()

        self._get_clouds()
        self._get_folders()

        self._get_all_hosts()
        self._process_hosts()
aleksey@first:~/OtusTeam/IaC/les13/plugin$ ansible-inventory --list
{
    "_meta": {
        "hostvars": {
            "test": {
                "ansible_host": "89.169.147.135"
            }
        }
    },
    "all": {
        "children": [
            "ungrouped",
            "yacloud"
        ]
    },
    "yacloud": {
        "hosts": [
            "test"
        ]
    }
}

ansible.cfg  ans_inv_list.sh  ans_ping.sh  create_vm.sh  export_plg.sh  inventory  plugins  running.log  set_grep_ANSIBLE.sh
aleksey@first:~/OtusTeam/IaC/les13/plugin$ ./ans_inv_list.sh 
++ ansible-inventory --list
{
    "_meta": {
        "hostvars": {
            "test": {
                "ansible_host": "89.169.147.135"
            }
        }
    },
    "all": {
        "children": [
            "ungrouped",
            "yacloud"
        ]
    },
    "yacloud": {
        "hosts": [
            "test"
        ]
    }
}
aleksey@first:~/OtusTeam/IaC/les13/plugin$ ./ans_ping.sh 
++ ansible -m ping all
test | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
